#pragma once
//@author Maltseva K.V.
#include<cassert>
#include"LinkedList.h"
//создание двусвязного списка
LinkedList<int> CteateTestList() {
	LinkedList<int> list;
	list.InsertTail(10);
	list.InsertTail(11);
	list.InsertTail(6);
	list.InsertTail(34);
	list.InsertTail(15);
	list.InsertTail(28);
	return list;
}
//тест начала итератора 
void TestLinkedListBegin() {
	// Создаем двусвязный список
	LinkedList<int> list = CteateTestList();

	// Получаем итератор начала списка
	auto it = list.begin();

	// Проверяем значение текущего узла через оператор разыменования
	assert(*it == 10);

	cout << "Итератор начала списка пройден" << endl;
}
//тест конца итератора 
void TestLinkedListEnd() {
	// Создаем двусвязный список
	LinkedList<int> list = CteateTestList();

	// Получаем итератор конца списка
	auto it = list.end();

	// Проверяем значение текущего узла через оператор разыменования
	assert(*it !=28);

	cout << "Итератор конца списка пройден" << endl;
}
//тест доступа к данным 
void TestDataOperator() {
	// Создаем двусвязный список
	LinkedList<int> list = CteateTestList();

	// Получаем итератор начала списка
	auto it = list.begin();
	
	// Проверяем значение текущего узла через оператор разыменования
	assert(*it == 10);

	// Переходим к следующему узлу
	++it;

	// Проверяем значение текущего узла через оператор разыменования
	assert(*it == 11);

	cout << "Оператор разыменования пройден" << endl;
}
//тест инкремента итератора
void TestIncOperator() {
	// Создаем двусвязный список
	LinkedList<int> list = CteateTestList();
	// Получаем итератор начала списка
		auto it = list.begin();

	// Проверяем значение текущего узла
	assert(*it == 10);

	// Переходим к следующему узлу с помощью оператора инкремента
	++it;

	// Проверяем значение текущего узла после инкремента
	assert(*it == 11);

	// Переходим к следующему узлу с помощью оператора инкремента
	++it;

	// Проверяем значение текущего узла после инкремента
	assert(*it == 6);

	// Переходим к следующему узлу с помощью оператора инкремента
	++it;
	// Проверяем значение текущего узла после инкремента
	assert(*it == 34);
	// Переходим к следующему узлу с помощью оператора инкремента
	++it;
	// Проверяем значение текущего узла после инкремента
	assert(*it == 15);
	// Переходим к следующему узлу с помощью оператора инкремента
	++it;
	// Проверяем значение текущего узла после инкремента
	assert(*it == 28);
	// Переходим к следующему узлу с помощью оператора инкремента
	++it;
	// Проверяем, что после достижения конца списка итератор равен end
	assert(it == list.end());
	cout << "Оператор инкремента пройден" << endl;
}
//тест оператора равенства
void TestOperatorEqual() {
	// Создаем двусвязный список
	LinkedList<int> list = CteateTestList();

	// Получаем итераторы
	auto it1 = list.begin();
	auto it2 = list.begin();

	// Проверяем, что итераторы равны друг другу с помощью оператора равенства
	assert(it1 == it2);



	cout << "Оператор равенства пройден" << endl;
}
//тест оперратора неравенства
void TestOperatorUnequal() {
	// Создаем двусвязный список
	LinkedList<int> list = CteateTestList();

	// Получаем итераторы
	auto it1 = list.begin();
	auto it2 = list.begin();
	++it2;

	// Проверяем, что итераторы не равны друг другу с помощью оператора неравенства
	assert(it1 != it2);
	cout << "Оператор неравенства пройден" << endl;


}